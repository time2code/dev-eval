/* global jest describe beforeEach it expect */

'use strict';

jest.dontMock('../components/Button');
jest.dontMock('../utils/inject-style');
jest.dontMock('../utils/union-class-names');

var React = require('react/addons');
var TestUtils = React.addons.TestUtils;

var injectStyle = require('../utils/inject-style');

// Babel would move an import in front of the jest.dontMock. That's why require
// is used instead of import.
var Button = require('../components/Button');

describe('Button', function () {
  describe('without any properties', function () {
    var button = undefined;
    var buttonNode = undefined;

    beforeEach(function () {
      injectStyle.injectStyles = jest.genMockFunction();
      button = TestUtils.renderIntoDocument(React.createElement(
        Button,
        null,
        'Follow'
      ));
      buttonNode = TestUtils.findRenderedDOMComponentWithTag(button, 'button');
    });

    it('should come with default styles', function () {
      expect(buttonNode.props.style).toBeDefined();
    });

    it('should set the type to button by default', function () {
      expect(buttonNode.props.type).toBe('button');
    });

    it('should inject styles for hover, active & foucs', function () {
      expect(injectStyle.injectStyles.mock.calls.length).toBe(1);

      var styles = injectStyle.injectStyles.mock.calls[0][0];
      expect(styles[0].pseudoClass).toBe('hover');
      expect(styles[1].pseudoClass).toBe('active');
      expect(styles[2].pseudoClass).toBe('hover');
      expect(styles[2].disabled).toBeTruthy();
      expect(styles[3].pseudoClass).toBe('focus');
    });
  });

  it('should be able to bind onClick', function () {
    var wasClicked = false;

    // Render a button with an onClick handler
    var button = TestUtils.renderIntoDocument(React.createElement(
      Button,
      { onClick: function () {
          wasClicked = true;
        } },
      'Follow'
    ));

    // Simulate a click
    TestUtils.Simulate.click(TestUtils.findRenderedDOMComponentWithTag(button, 'button'));

    expect(wasClicked).toBeTruthy();
  });

  it('should be able to provide a className', function () {
    var button = TestUtils.renderIntoDocument(React.createElement(
      Button,
      { className: 'test-me' },
      'Follow'
    ));

    var buttonNode = TestUtils.findRenderedDOMComponentWithTag(button, 'button');
    expect(buttonNode.props.className).toContain('test-me');
  });

  it('should be able to adopt the style of the button', function () {
    var button = TestUtils.renderIntoDocument(React.createElement(
      Button,
      { style: { color: '#F00' } },
      'Follow'
    ));

    var buttonNode = TestUtils.findRenderedDOMComponentWithTag(button, 'button');
    expect(buttonNode.props.style.color).toBe('#F00');
  });

  it('should be able to use a primary button', function () {
    var defaultButton = TestUtils.renderIntoDocument(React.createElement(
      Button,
      null,
      'Follow'
    ));

    var primaryButton = TestUtils.renderIntoDocument(React.createElement(
      Button,
      { primary: true },
      'Follow'
    ));

    var defaultButtonNode = TestUtils.findRenderedDOMComponentWithTag(defaultButton, 'button');
    var prmaryButtonNode = TestUtils.findRenderedDOMComponentWithTag(primaryButton, 'button');

    expect(prmaryButtonNode.props.style.background).not.toEqual(defaultButtonNode.props.style.background);
  });

  it('should be able to change the type to submit or reset', function () {
    var submitButton = TestUtils.renderIntoDocument(React.createElement(
      Button,
      { type: 'submit' },
      'Submit'
    ));
    var submitButtonNode = TestUtils.findRenderedDOMComponentWithTag(submitButton, 'button');
    expect(submitButtonNode.props.type).toBe('submit');

    var resetButton = TestUtils.renderIntoDocument(React.createElement(
      Button,
      { type: 'reset' },
      'Submit'
    ));
    var resetButtonNode = TestUtils.findRenderedDOMComponentWithTag(resetButton, 'button');
    expect(resetButtonNode.props.type).toBe('reset');
  });

  it('should be able to adopt the pseudoClass styles of the button', function () {
    injectStyle.injectStyles = jest.genMockFunction();

    var bodyWithButton = TestUtils.renderIntoDocument(React.createElement(
      Button,
      { hoverStyle: { color: 'red' },
        focusStyle: { color: 'brown' },
        activeStyle: { color: 'green' },
        preventFocusStyleForTouchAndClick: false },
      'Follow'
    ));

    TestUtils.findRenderedDOMComponentWithTag(bodyWithButton, 'button');

    expect(injectStyle.injectStyles.mock.calls.length).toBe(1);

    var styles = injectStyle.injectStyles.mock.calls[0][0];

    expect(styles[0].pseudoClass).toBe('hover');
    expect(styles[0].style.color).toBe('red');
    expect(styles[1].pseudoClass).toBe('active');
    expect(styles[1].style.color).toBe('green');
    expect(styles[3].pseudoClass).toBe('focus');
    expect(styles[3].style.color).toBe('brown');
  });

  it('should remove the custom styles from the dom when the button unmounts', function () {
    injectStyle.removeStyle = jest.genMockFunction();
    expect(injectStyle.removeStyle.mock.calls.length).toBe(0);

    var button = TestUtils.renderIntoDocument(React.createElement(
      Button,
      null,
      'Follow'
    ));

    button.componentWillUnmount();

    expect(injectStyle.removeStyle.mock.calls.length).toBe(1);
  });
});